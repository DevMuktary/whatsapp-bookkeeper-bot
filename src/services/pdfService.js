import PDFDocument from 'pdfkit';
import axios from 'axios';
import logger from '../utils/logger.js';

const COLORS = {
    primary: '#2c3e50',    
    accent: '#3498db',     
    text: '#444444',       
    grayLight: '#f4f6f7',  
    border: '#e0e0e0'      
};

const FONTS = {
    bold: 'Helvetica-Bold',
    regular: 'Helvetica',
    italic: 'Helvetica-Oblique'
};

const formatCurrency = (amount, currency) => {
    const num = new Intl.NumberFormat('en-US', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
    }).format(amount);
    return `${currency} ${num}`;
};

const formatDate = (dateInput) => {
    if (!dateInput) return '';
    const date = new Date(dateInput);
    return new Intl.DateTimeFormat('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    }).format(date);
};

async function fetchChartImage(chartConfig) {
    try {
        const response = await axios.post('https://quickchart.io/chart', {
            backgroundColor: 'white',
            width: 500,
            height: 300,
            format: 'png',
            chart: chartConfig
        }, {
            responseType: 'arraybuffer'
        });
        return response.data;
    } catch (error) {
        logger.error('Error fetching chart:', error.message);
        return null; 
    }
}

const drawFooter = (doc) => {
    const range = doc.bufferedPageRange(); 
    for (let i = 0; i < range.count; i++) {
        doc.switchToPage(i);
        doc.save(); 
        doc.page.margins = { top: 0, bottom: 0, left: 0, right: 0 };
        doc.strokeColor(COLORS.border).lineWidth(1)
           .moveTo(50, doc.page.height - 50)
           .lineTo(550, doc.page.height - 50)
           .stroke();
        doc.fillColor('#999999').fontSize(8)
           .text('Generated by Fynax', 50, doc.page.height - 40, { align: 'left', width: 200, lineBreak: false });
        doc.text(`Page ${i + 1} of ${range.count}`, 350, doc.page.height - 40, { align: 'right', width: 200, lineBreak: false });
        doc.restore();
    }
};

const drawHeader = (doc, user, title, period) => {
    doc.fillColor(COLORS.primary)
       .fontSize(20)
       .font(FONTS.bold)
       .text(user.businessName, 50, 45, { align: 'left' });
       
    const pageWidth = doc.page.width;
    doc.rect(pageWidth - 250, 35, 200, 25).fill(COLORS.grayLight);
    
    doc.fillColor(COLORS.text)
       .fontSize(12)
       .font(FONTS.bold)
       .text(title.toUpperCase(), pageWidth - 250, 42, { width: 200, align: 'center' });

    if (period) {
        doc.fontSize(10)
           .font(FONTS.regular)
           .text(period, pageWidth - 250, 65, { width: 200, align: 'center' });
    }

    doc.strokeColor(COLORS.accent)
       .lineWidth(2)
       .moveTo(50, 90)
       .lineTo(550, 90)
       .stroke();
       
    doc.moveDown(2);
    return doc.y + 20; 
};

const drawTableRow = (doc, y, columns, isHeader = false, isStriped = false, rowHeight = 20) => {
    if (isHeader) {
        doc.rect(50, y - 5, 500, rowHeight + 5).fill(COLORS.primary);
        doc.fillColor('#FFFFFF').font(FONTS.bold).fontSize(10);
    } else {
        if (isStriped) doc.rect(50, y - 5, 500, rowHeight + 5).fill(COLORS.grayLight);
        doc.fillColor(COLORS.text).font(FONTS.regular).fontSize(10);
    }

    columns.forEach(col => {
        doc.text(col.text, col.x, y, { width: col.width, align: col.align || 'left' });
    });
    
    doc.fillColor(COLORS.text);
};

export function generateSalesReport(user, transactions, periodTitle) {
    return new Promise(async (resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50, size: 'A4', bufferPages: true });
            const buffers = [];
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => resolve(Buffer.concat(buffers)));

            let currentY = drawHeader(doc, user, 'Sales Report', periodTitle);

            const salesByDate = {};
            transactions.forEach(tx => {
                const dateKey = new Date(tx.date).toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit' }); 
                salesByDate[dateKey] = (salesByDate[dateKey] || 0) + tx.amount;
            });
            const sortedDates = Object.keys(salesByDate).sort((a,b) => {
                 const [d1, m1] = a.split('/');
                 const [d2, m2] = b.split('/');
                 return new Date(2024, m1-1, d1) - new Date(2024, m2-1, d2);
            });

            if (sortedDates.length > 1) {
                const chartBuffer = await fetchChartImage({
                    type: 'line',
                    data: {
                        labels: sortedDates,
                        datasets: [{
                            label: 'Daily Sales Trend',
                            data: sortedDates.map(d => salesByDate[d]),
                            fill: false,
                            borderColor: '#3498db',
                            tension: 0.3
                        }]
                    }
                });

                if (chartBuffer) {
                    doc.image(chartBuffer, 50, currentY, { width: 500, height: 250, align: 'center' });
                    currentY += 270; 
                }
            }

            const colDate = { x: 50, width: 65, align: 'left' };
            const colCust = { x: 120, width: 90, align: 'left' };
            const colDesc = { x: 220, width: 190, align: 'left' };
            const colAmt = { x: 420, width: 100, align: 'right' };

            if (currentY + 50 > 750) { doc.addPage(); currentY = 50; }

            drawTableRow(doc, currentY, [
                { text: 'DATE', ...colDate },
                { text: 'CUSTOMER', ...colCust },
                { text: 'DESCRIPTION / ITEMS', ...colDesc },
                { text: 'AMOUNT', ...colAmt }
            ], true);
            currentY += 25;

            let totalSales = 0;
            transactions.forEach((tx, i) => {
                totalSales += tx.amount;
                const formattedAmount = formatCurrency(tx.amount, user.currency);
                const customerName = tx.customerName || 'Walk-in';
                
                let descriptionText = "";
                if (tx.items && tx.items.length > 0) {
                    descriptionText = tx.items.map(item => `â€¢ ${item.quantity}x ${item.productName}`).join('\n');
                } else {
                    descriptionText = tx.description.replace(/ sold to .*/i, '') || 'Sale';
                }

                const descHeight = doc.heightOfString(descriptionText, { width: colDesc.width });
                const rowHeight = Math.max(descHeight, 20); 

                if (currentY + rowHeight > 750) { 
                    doc.addPage(); 
                    currentY = 50; 
                    drawTableRow(doc, currentY, [
                        { text: 'DATE', ...colDate },
                        { text: 'CUSTOMER', ...colCust },
                        { text: 'DESCRIPTION / ITEMS', ...colDesc },
                        { text: 'AMOUNT', ...colAmt }
                    ], true);
                    currentY += 25;
                }
                
                drawTableRow(doc, currentY, [
                    { text: formatDate(tx.date), ...colDate },
                    { text: customerName, ...colCust },
                    { text: descriptionText, ...colDesc },
                    { text: formattedAmount, ...colAmt }
                ], false, i % 2 === 0, rowHeight);
                
                currentY += (rowHeight + 10); 
            });

            currentY += 10;
            if (currentY > 750) { doc.addPage(); currentY = 50; }
            doc.moveTo(50, currentY).lineTo(550, currentY).strokeColor(COLORS.border).stroke();
            currentY += 10;
            
            doc.font(FONTS.bold).fontSize(12).text('Total Sales:', 300, currentY, { align: 'right', width: 100 });
            doc.fillColor(COLORS.accent).text(formatCurrency(totalSales, user.currency), 410, currentY, { align: 'right', width: 110 });

            drawFooter(doc);
            doc.end();
        } catch (error) {
            logger.error('Error generating PDF report:', error);
            reject(error);
        }
    });
}

export function generateExpenseReport(user, transactions, periodTitle) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50, size: 'A4', bufferPages: true });
            const buffers = [];
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => resolve(Buffer.concat(buffers)));

            let currentY = drawHeader(doc, user, 'Expense Report', periodTitle);

            const cols = [
                { id: 'date', x: 60, width: 80, label: 'DATE' },
                { id: 'cat', x: 150, width: 100, label: 'CATEGORY' },
                { id: 'desc', x: 260, width: 140, label: 'DESCRIPTION' },
                { id: 'amt', x: 410, width: 130, label: 'AMOUNT', align: 'right' }
            ];

            drawTableRow(doc, currentY, cols.map(c => ({ text: c.label, x: c.x, width: c.width, align: c.align })), true);
            currentY += 25;

            let totalExpenses = 0;
            transactions.forEach((tx, i) => {
                if (currentY > 750) { doc.addPage(); currentY = 50; }
                
                totalExpenses += tx.amount;
                
                drawTableRow(doc, currentY, [
                    { text: formatDate(tx.date), ...cols[0] },
                    { text: tx.category || 'Uncategorized', ...cols[1] },
                    { text: tx.description, ...cols[2] },
                    { text: formatCurrency(tx.amount, user.currency), ...cols[3] }
                ], false, i % 2 === 0);
                currentY += 20;
            });

            currentY += 10;
            doc.moveTo(50, currentY).lineTo(550, currentY).strokeColor(COLORS.border).stroke();
            currentY += 10;
            doc.font(FONTS.bold).fontSize(12).fillColor(COLORS.text).text('Total Expenses:', 250, currentY, { align: 'right', width: 150 });
            doc.fillColor('red').text(formatCurrency(totalExpenses, user.currency), 410, currentY, { align: 'right', width: 130 });

            drawFooter(doc);
            doc.end();

        } catch (error) {
            logger.error('Error generating Expense PDF report:', error);
            reject(error);
        }
    });
}

export function generateInventoryReport(user, products) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 40, size: 'A4', bufferPages: true });
            const buffers = [];
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => resolve(Buffer.concat(buffers)));

            let currentY = drawHeader(doc, user, 'Inventory Report', `As of ${formatDate(new Date())}`);

            const colName = { x: 50, width: 160 };
            const colQty = { x: 220, width: 40, align: 'center' };
            const colCost = { x: 285, width: 80, align: 'right' }; 
            const colSell = { x: 395, width: 85, align: 'right' }; 
            const colVal = { x: 480, width: 70, align: 'right' };

            drawTableRow(doc, currentY, [
                { text: 'PRODUCT', ...colName },
                { text: 'QTY', ...colQty },
                { text: 'COST PRICE', ...colCost },
                { text: 'SELLING PRICE', ...colSell },
                { text: 'VALUE', ...colVal },
            ], true);
            currentY += 25;

            let totalValue = 0;

            products.forEach((p, i) => {
                if (currentY > 750) { doc.addPage(); currentY = 50; }
                
                const itemValue = p.quantity * p.costPrice;
                totalValue += itemValue;
                
                drawTableRow(doc, currentY, [
                    { text: p.productName, ...colName },
                    { text: p.quantity.toString(), ...colQty },
                    { text: new Intl.NumberFormat('en-US').format(p.costPrice), ...colCost },
                    { text: new Intl.NumberFormat('en-US').format(p.sellingPrice), ...colSell },
                    { text: new Intl.NumberFormat('en-US').format(itemValue), ...colVal },
                ], false, i % 2 === 0);
                currentY += 20;
            });

            currentY += 15;
            doc.rect(300, currentY - 5, 250, 30).fill(COLORS.grayLight);
            doc.fillColor(COLORS.primary).font(FONTS.bold).fontSize(12)
               .text('Total Inventory Value:', 310, currentY, { width: 140, align: 'right' });
            doc.fillColor(COLORS.accent).text(formatCurrency(totalValue, user.currency), 460, currentY, { width: 90, align: 'right' });

            drawFooter(doc);
            doc.end();

        } catch (error) {
            logger.error('Error generating Inventory PDF report:', error);
            reject(error);
        }
    });
}

export function generatePnLReport(user, pnlData, periodTitle) {
    return new Promise(async (resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50, size: 'A4', bufferPages: true });
            const buffers = [];
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => resolve(Buffer.concat(buffers)));

            let y = drawHeader(doc, user, 'Profit & Loss', periodTitle);
            const rightX = 400;
            const widthAmt = 140;

            const drawSection = (title, amount, isNegative = false) => {
                if (y > 750) { doc.addPage(); y = 50; }
                doc.font(FONTS.bold).fontSize(12).fillColor(COLORS.primary).text(title, 60, y);
                doc.font(FONTS.regular).fillColor(isNegative ? 'red' : COLORS.text)
                   .text(formatCurrency(amount, user.currency), rightX, y, { align: 'right', width: widthAmt });
                y += 25;
            };

            const drawSubItem = (label, amount) => {
                if (y > 750) { doc.addPage(); y = 50; }
                doc.font(FONTS.regular).fontSize(10).fillColor(COLORS.text).text(label, 80, y);
                doc.text(formatCurrency(amount, user.currency), rightX, y, { align: 'right', width: widthAmt });
                y += 20;
            };

            const drawLine = () => {
                doc.moveTo(60, y).lineTo(540, y).strokeColor(COLORS.border).stroke();
                y += 15;
            }

            drawSection('Revenue', pnlData.totalSales);
            drawLine();

            drawSection('Cost of Goods Sold', pnlData.totalCogs);
            drawLine();

            if (y > 750) { doc.addPage(); y = 50; }
            doc.rect(50, y - 5, 500, 30).fill('#e8f4fc');
            doc.fillColor(COLORS.primary).font(FONTS.bold).fontSize(14).text('Gross Profit', 60, y + 5);
            doc.text(formatCurrency(pnlData.grossProfit, user.currency), rightX, y + 5, { align: 'right', width: widthAmt });
            y += 40;

            if (y > 750) { doc.addPage(); y = 50; }
            doc.font(FONTS.bold).fontSize(12).fillColor(COLORS.primary).text('Operating Expenses', 60, y);
            y += 20;
            
            pnlData.topExpenses.forEach(exp => {
                drawSubItem(exp.category || exp._id, exp.amount);
            });
            y += 10;
            
            if (y > 750) { doc.addPage(); y = 50; }
            doc.moveTo(350, y).lineTo(540, y).stroke();
            y += 10;
            doc.font(FONTS.bold).text('Total Expenses', 250, y, { align: 'right', width: 140 });
            doc.text(formatCurrency(pnlData.totalExpenses, user.currency), rightX, y, { align: 'right', width: widthAmt });
            y += 30;

            if (y > 750) { doc.addPage(); y = 50; }
            const isLoss = pnlData.netProfit < 0;
            const bg = isLoss ? '#fce8e8' : '#e8fce8';
            doc.rect(50, y - 10, 500, 40).fill(bg);
            
            doc.fillColor(COLORS.primary).fontSize(16).font(FONTS.bold).text('Net Profit / (Loss)', 60, y);
            doc.fillColor(isLoss ? 'red' : 'green')
               .text(formatCurrency(pnlData.netProfit, user.currency), rightX, y, { align: 'right', width: widthAmt });

            if (pnlData.topExpenses && pnlData.topExpenses.length > 0) {
                if (y + 320 > 750) { doc.addPage(); y = 50; }
                else { y += 50; } 

                const chartBuffer = await fetchChartImage({
                    type: 'doughnut',
                    data: {
                        labels: pnlData.topExpenses.map(e => e.category || e._id),
                        datasets: [{
                            data: pnlData.topExpenses.map(e => e.amount),
                            backgroundColor: ['#e74c3c', '#3498db', '#f1c40f', '#2ecc71', '#9b59b6', '#34495e']
                        }]
                    },
                    options: {
                        plugins: {
                            title: { display: true, text: 'Expense Breakdown' },
                            legend: { position: 'right' }
                        }
                    }
                });

                if (chartBuffer) {
                    doc.image(chartBuffer, 50, y, { width: 500, height: 280, align: 'center' });
                }
            }

            drawFooter(doc);
            doc.end();

        } catch (error) {
            logger.error('Error generating P&L PDF report:', error);
            reject(error);
        }
    });
}

export function generateInvoice(user, transaction, customer) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument({ margin: 50, size: 'A4', bufferPages: true });
            const buffers = [];
            doc.on('data', buffers.push.bind(buffers));
            doc.on('end', () => resolve(Buffer.concat(buffers)));

            doc.rect(0, 0, 600, 120).fill(COLORS.primary);
            
            doc.fillColor('#FFFFFF').fontSize(24).font(FONTS.bold)
               .text(user.businessName, 50, 40);
            doc.fontSize(10).font(FONTS.regular).text(user.email || '', 50, 70);
            
            doc.fontSize(30).text('INVOICE', 400, 40, { align: 'right' });
            doc.fontSize(10).text(`#${transaction._id.toString().slice(-8).toUpperCase()}`, 400, 80, { align: 'right' });

            let y = 150;

            doc.fillColor(COLORS.text);
            doc.fontSize(10).font(FONTS.bold).text('BILL TO:', 50, y);
            doc.font(FONTS.regular).text(customer.customerName, 50, y + 15);
            
            doc.font(FONTS.bold).text('DATE:', 400, y, { align: 'right', width: 50 });
            doc.font(FONTS.regular).text(formatDate(transaction.date), 460, y, { align: 'right', width: 80 });
            
            y += 60;

            const colItem = { x: 50, width: 250 };
            const colQty = { x: 310, width: 50, align: 'center' };
            const colPrice = { x: 370, width: 80, align: 'right' };
            const colTotal = { x: 460, width: 80, align: 'right' };

            drawTableRow(doc, y, [
                { text: 'ITEM DESCRIPTION', ...colItem },
                { text: 'QTY', ...colQty },
                { text: 'PRICE', ...colPrice },
                { text: 'TOTAL', ...colTotal },
            ], true);
            y += 30;

            transaction.items.forEach((item, i) => {
                const itemTotal = item.quantity * item.pricePerUnit;
                drawTableRow(doc, y, [
                    { text: item.productName, ...colItem },
                    { text: item.quantity.toString(), ...colQty },
                    { text: formatCurrency(item.pricePerUnit, user.currency), ...colPrice },
                    { text: formatCurrency(itemTotal, user.currency), ...colTotal },
                ], false, i % 2 === 0);
                y += 25;
            });

            y += 20;
            const totalBoxX = 350;
            
            doc.moveTo(totalBoxX, y).lineTo(550, y).strokeColor(COLORS.accent).lineWidth(2).stroke();
            y += 15;

            doc.fillColor(COLORS.primary).font(FONTS.bold).fontSize(14)
               .text('Grand Total', totalBoxX, y, { width: 80, align: 'left' });
            
            doc.fillColor(COLORS.accent).fontSize(14)
               .text(formatCurrency(transaction.amount, user.currency), 440, y, { width: 100, align: 'right' });

            const pageHeight = doc.page.height;
            doc.rect(0, pageHeight - 80, 600, 80).fill('#f9f9f9');
            
            doc.fillColor(COLORS.text).fontSize(10).font(FONTS.italic)
               .text('Thank you for your business!', 50, pageHeight - 50, { align: 'center', width: 500 });

            doc.end();

        } catch (error) {
            logger.error('Error generating invoice PDF:', error);
            reject(error);
        }
    });
}
